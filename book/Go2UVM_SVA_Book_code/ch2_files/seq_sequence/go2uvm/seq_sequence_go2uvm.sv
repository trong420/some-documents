/********************************************
* VerifWorks Go2UVM App: VW_DVC_Go2UVM
* Automatically generated by VerifWorks's DVC_Go2UVM Riviera Apps 
* Thanks for using VerifWorks products
* Visit http://www.verifworks.com for more 
* Generated on   : 2016-06-04 15:04:22
********************************************/ 



// Generating SystemVerilog interface for module: seq_sequence
// ---------------------------------------------------------
interface seq_sequence_if (input logic clk,clk2);
  logic  [0:0] a;
  logic  [0:0] a8;
  logic  [0:0] b;
  logic  [0:0] b8;
  logic  [0:0] c;
  logic  [0:0] reset_n;
//  logic  [0:0] clk2;
  logic  [0:0] d;
  logic  [0:0] e;
  logic  [0:0] f;
//  logic : Signed Bit [31:0] i;
//  logic : Signed Bit [31:0] j;
  // End of interface signals 


  // Start of clocking block definition 
  clocking cb @(posedge clk or posedge clk2);
    output a;
    output a8;
    output b;
    output b8;
    output c;
    output reset_n;
  //  output clk2;
    output d;
    output e;
    output f;
  //  output i;
  //  output j;
  endclocking : cb
  // End of clocking block definition 

endinterface : seq_sequence_if
// Automatically generated from VerifWorks's DVCreate-Go2UVM product
// Thanks for using VerifWorks products, see http://www.verifworks.com for more

import uvm_pkg::*;
`include "uvm_macros.svh"
// Import Go2UVM Package
import vw_go2uvm_pkg::*;
// Use the base class provided by the vw_go2uvm_pkg
class seq_sequence_test extends go2uvm_base_test;
  // Create a handle to the actual interface
  virtual seq_sequence_if vif;
  task reset;
    `uvm_info (log_id, "Start of reset", UVM_MEDIUM)
    //`uvm_info (log_id, "Fill in your reset logic here ", UVM_MEDIUM)
     this.vif.cb.reset_n <= 1'b0;
     repeat (5) @ (this.vif.cb);
     this.vif.cb.reset_n <= 1'b1;
     repeat (1) @ (this.vif.cb);
    `uvm_info (log_id, "End of reset", UVM_MEDIUM)
  endtask : reset
  task main ();
    `uvm_info (log_id, "Start of main", UVM_MEDIUM)
   // `uvm_info (log_id, "Fill in your main logic here ", UVM_MEDIUM)
	@(vif.cb);
		begin
		 @(vif.cb);
		    vif.cb.a <= 1'b1;
		    vif.cb.b <= 1'b1;
		    vif.cb.c <= 1'b1;
		    vif.cb.d <= 1'b1;
		    vif.cb.e <= 1'b1;
		    vif.cb.f <= 1'b1;
		    vif.cb.a8 <= 1'b1;
		    vif.cb.b8 <= 1'b1;
		 @(vif.cb);
		 @(vif.cb);
		 @(vif.cb);
		 @(vif.cb);
		 @(vif.cb);

		    vif.cb.a <= 1'b0;
		    vif.cb.b <= 1'b0;
		    vif.cb.c <= 1'b0;
		    vif.cb.d <= 1'b0;
		    vif.cb.e <= 1'b0;
		    vif.cb.f <= 1'b0;
		    vif.cb.a8 <= 1'b0;
		    vif.cb.b8 <= 1'b0;
		end
#200 $finish;
    `uvm_info (log_id, "End of main", UVM_MEDIUM)
  endtask : main
endclass : seq_sequence_test

module seq_sequence_go2uvm;
  timeunit 1ns;
  timeprecision 1ns;
  parameter VW_CLK_PERIOD = 10;

  // Simple clock generator
  bit clk,clk2 ;
  always # (VW_CLK_PERIOD/2) clk <= ~clk;
  always # (VW_CLK_PERIOD/2) clk2 <= ~clk2;
  // Interface instance
  seq_sequence_if seq_sequence_if_0 (.*);

  // Connect TB clk to Interface instance clk

  // DUT instance
  seq_sequence seq_sequence_0 (.clk(clk),
                    .clk2(clk2),
                    .d(seq_sequence_if_0.d),
                    .a(seq_sequence_if_0.a),
                    .b(seq_sequence_if_0.b),
                    .c(seq_sequence_if_0.c),
                    .e(seq_sequence_if_0.e),
		     .f(seq_sequence_if_0.f),
		     .reset_n(seq_sequence_if_0.reset_n),
		     .a8(seq_sequence_if_0.a8),
		     .b8(seq_sequence_if_0.b8)
		     // .i(if_0.i),
		//	.j(if_0.j)     
 			);


  // Using VW_Go2UVM
  seq_sequence_test seq_sequence_test_0;
  initial begin : go2uvm_test
    seq_sequence_test_0 = new ();
    // Connect virtual interface to physical interface
    seq_sequence_test_0.vif = seq_sequence_if_0;
    // Kick start standard UVM phasing
    run_test ();
  end : go2uvm_test
endmodule : seq_sequence_go2uvm

